package com.cout970.magneticraft.api.electricity.prefab;

import com.cout970.magneticraft.api.electricity.*;
import com.cout970.magneticraft.api.util.MgUtils;
import com.cout970.magneticraft.api.util.VecDouble;
import net.minecraft.nbt.NBTTagCompound;
import net.minecraft.util.BlockPos;
import net.minecraft.world.World;

public class InterPoleWire implements IInterPoleWire {

    protected World w;
    protected BlockPos start;
    protected BlockPos end;
    //cache
    protected IElectricPole cache_start;
    protected IElectricPole cache_end;
    protected double distance;
    protected double energyFlow;

    public InterPoleWire(BlockPos s, BlockPos e) {
        start = s;
        end = e;
        VecDouble vec = new VecDouble(s).add(new VecDouble(e).getOpposite());
        distance = vec.mag();
    }

    public InterPoleWire() {
    }

    public void iterate() {
        valanceConductors(this);
    }

    public double getEnergyFlow() {
        return energyFlow;
    }

    public void setEnergyFlow(double energyFlow) {
        this.energyFlow = energyFlow;
    }

    public IElectricPole getStart() {
        if (cache_start == null) {
            cache_start = ElectricUtils.getElectricPole(w.getTileEntity(start));
        }
        return cache_start;
    }

    public IElectricPole getEnd() {
        if (cache_end == null) {
            cache_end = ElectricUtils.getElectricPole(w.getTileEntity(end));
        }
        return cache_end;
    }

    public BlockPos posStart() {
        return new BlockPos(start);
    }

    public BlockPos posEnd() {
        return new BlockPos(start);
    }

    public double getDistance() {
        return distance;
    }

    public void save(NBTTagCompound nbt) {
        MgUtils.writePos(nbt, "Start", start);
        MgUtils.writePos(nbt, "End", end);
        nbt.setDouble("EnergyFlow", energyFlow);
    }

    public void load(NBTTagCompound nbt) {
        start = MgUtils.readPos(nbt, "Start");
        end = MgUtils.readPos(nbt, "End");
        energyFlow = nbt.getDouble("EnergyFlow");
        VecDouble vec = new VecDouble(start).add(new VecDouble(end).getOpposite());
        distance = vec.mag();
    }

    public static void valanceConductors(IInterPoleWire con) {
        if (con.getStart() == null || con.getEnd() == null) return;
        //the resistance of the connection
        double resistance = con.getDistance() * ElectricConstants.RESISTANCE_COPPER_WIRE;
        IElectricConductor cond_start = con.getStart().getConductor();
        IElectricConductor cond_end = con.getEnd().getConductor();
        //the voltage difference
        double deltaV = cond_start.getVoltage() - cond_end.getVoltage();
        //sanity check for infinite current
        if (Double.isNaN(con.getEnergyFlow())) con.setEnergyFlow(0);
        //the extra current from the last tick
        double current = con.getEnergyFlow();
        // (V - I*R) I*R is the voltage difference that this conductor should have using the ohm's law, and V the actual one
        //vDiff is the voltage difference between the current voltage difference and the proper voltage difference using the ohm's law
        double vDiff = (deltaV - current * resistance);
        //make sure the vDiff is not in the incorrect direction when the resistance is too big
        vDiff = Math.min(vDiff, Math.abs(deltaV));
        vDiff = Math.max(vDiff, -Math.abs(deltaV));
        // add to the next tick current an extra to get the proper voltage difference on the two conductors
        con.setEnergyFlow(con.getEnergyFlow() + (vDiff * cond_start.getIndScale()) / cond_start.getVoltageMultiplier());
        // to the extra current add the current generated by the voltage difference
        current += (deltaV * 0.5D) / (cond_start.getVoltageMultiplier());
        //moves the charge
        cond_start.applyCurrent(-current);
        cond_end.applyCurrent(current);
    }

    @Override
    public void setWorld(World w) {
        this.w = w;
    }

    @Override
    public World getWorld() {
        return w;
    }
}
